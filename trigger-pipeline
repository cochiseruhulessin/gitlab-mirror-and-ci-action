#!/usr/bin/env python3
import json
import os
import sys
import time

import requests


FAILED_STATES = ['canceled', 'failed']
GITLAB_HOSTNAME = os.environ['GITLAB_HOSTNAME']
GITLAB_TOKEN = os.environ['GITLAB_PASSWORD']
GITLAB_PROJECT_ID = os.environ['GITLAB_PROJECT_ID']
PASS_VARIABLES = os.getenv('PASS_VARIABLES')


def get_environment():
    """Return a dictionary holding the environment variables used by the pipeline."""
    if not PASS_VARIABLES:
        return
    environ = {}
    for k in filter(bool, str.split(PASS_VARIABLES, ':')):
        if not os.getenv(k):
            continue
        environ[k] = os.getenv(k)
    return [{'key': x, 'value': y} for x, y in dict.items(environ)]


def main(hostname, token, project_id, ref):
    headers = {'PRIVATE-TOKEN': token}
    endpoint = f"https://{hostname}/api/v4/projects/{project_id}/pipeline?ref={ref}"
    response = requests.post(endpoint, headers=headers)
    try:
        response.raise_for_status()
    except Exception as e:
        print(json.dumps(response.json(), indent=2))
        raise
    dto = response.json()
    print("remote:")
    print("remote: To view the GitLab pipeline for this action, visit:")
    print(f"remote: {dto['web_url']}")
    print("remote:")
          
    pipeline_id = dto['id']
    endpoint = f"https://{hostname}/api/v4/projects/{project_id}/pipelines/{pipeline_id}"
    while dto['finished_at'] is None:
        time.sleep(5)
        response = requests.get(endpoint, headers=headers)
        response.raise_for_status()
        dto = response.json()

    status = dto.get('status')
    if status in FAILED_STATES:
        print(f"Pipeline errored with status {status}", file=sys.stderr)
        sys.exit(1)
    print(f"Pipeline finished with state: {status}")


if __name__ == '__main__':
    main(GITLAB_HOSTNAME, GITLAB_TOKEN, GITLAB_PROJECT_ID, sys.argv[1])
